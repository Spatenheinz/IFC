\section{Introduction}

% learning objectives

% We can explain how VC generation works, and how it can be used for automatically proving certains properties about programs

% Can take a semantic, in form of inference rules, and translate it into concise and correct Haskell code

% Can write modular Haskell code that uses monad transformer stack to enable good seperation of concerns

% Attempted to support our claim of the correctness of our program by using automated testing

% The goal was to implement an assertion language that can be extended with the PER logic


% Project description
% The overreaching goal of the project is to investigate and work towards a language that uses formal logic in the context of Information Flow to secure confidential data. In the process we will go through the following steps:
%  Implement a simple while-language.
%  Implement program logic for the language, based on Hoare triples make a verification condition generator (VCG) possibility for discharging VCG potentially coupled with SMT solver / model checker.

%If time:
%  Extend the logic to "IF assertion language" based on PER. 3.5 Try to prove correctness of the implemented parts of the "IF assertion language" and program logic.
%  Extend the assertion language to include rules for Arrays and Procedures.

%Learning outcome:
%  Practical experience for proving semantic properties for a programming language.
%  Knowledge of how Hoare logic and PER logic can be used for Information Flow Control.
%  Describe how Verification Condition Generators are used.
%  Develop intuition for how Model Checkers work.

% -------------------------------

% topic
When writing code, you might be interested in verifying that your program does in fact do what you expect it to. 
In 1969 C.A.R. Hoare puplished a paper on an axiomatic system for proving correctness of programs, which laid the base for Hoare logic, a system for reasoning about program logic\cite{Hoare}. Using this logic, and the rules of inference that it introduces, one can formally prove the correctness of a program.
However, doing this by hand is time consuming, and can be expensive. 

In 1975, Dijkstra introduced \textit{predicate transformer semantics}, which is a way to find a suiting verification condition for a program, based on assertions about said program\cite{Dijkstra}.
This provides an approach for automatically generating conditions for which we can verify the correctness of certain programs.
% noget med information flow control??

% hvad er konteksten for problemet

% hvad er der blevet gjort før? 
% there are several programming languages allowing for verification condtition generation etc...
% Z3 why3
\textit{Why3} is an example of a platform in which such automatic program verification can be done. It requires the programmer to write assertions inside the program code of a \verb\WhyML\, and then utilises these assertions to compute a verification condition for the program.
When the verification condition is generated, it can discharge this condition to a variety of SMT solvers, which can then determine whether this condition can be proved.
Thus \textit{WhyML} is a programming language assertion interface, which allows automatic verification of programs by external SMT-solvers.

% vores løsningsforslag
\verb\WhyML\ is a language in the ML-family. In this project we present a small imperative language in the C-style family with built-in assertion language. This language uses Hoare logic and predicate tranformer semantics to allow for verification condition generation similar to \textit{Why3}. % coupled with Z3?

% hvad er vores mål med projektet
The main motivation for implementing this new language is to set a basis on which we can easily extend the language to include \verb\Partial Equivalence Relation\ (PER) logic, which is a logic proposed to reason about \textit{Information Flow Control}\cite{}. This can be used for making assertions about the security of code.
% IFC can help us assert that variables are safe...

% scope and limitations to the solution
This project implements a fairly simple language, with no arrays or procedures. When writing programs using this language, the programmer must write assertions about the code, and we can then prove the partial or total correctness of the program, depending on the given assertions.


















