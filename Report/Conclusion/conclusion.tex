\section{Conclusion}\label{sec:conclusion}
We have in this report presented the background for our project, which includes both the formal specification of the language, the axiomatic systems for Floyd-Hoare logic, and the predicate transformer semantics which we use to generate verification conditions for a program.
We have furthermore given a brief description of SMT-solvers and what their limitations are, along with how our language correspond to this.
We have presented essential design choices for the application and how we have transformed the semantics into Haskell code.
Lastly we have argued that our program is correctly able to statically prove correctness of certain programs, and dynamically evaluate same program with a correct result.
We have done so informally by tests and by a set of example programs, which show examples of both partial correctness and total correctness of certain programs.
We have furthermore looked at how the existing solution Why3 proves correctness, by comparing programs in \textit{While} to equivalent WhyML programs.
In the current state, the language is still sparse and quite restrictive. 
For the language to be used for more than just toying around, we propose three extensions which we find essential to the language in \cref{sec:future}.

\subsection{Future work}\label{sec:future}
We describe three extensions that would make the programming language more useful. 
The first extension is additional constructs for the language, which would give more expressive power to programs. 
The next is including more different program types, to allow for more usability. 
The final one is the extension to include PER logic in the implementation. This is the extension we find the most interesting, since the main idea of this project was to allow for reasoning about Information Flow of programs.

\subsubsection{Procedures and arrays}
We propose that the language is extended to include procedures and arrays. 
This would enable us to make more interesting examples programs, for example it would allow for better assertions. 
Imagine having a procedure which determines the maximum value of two integers. 
Then we could use this in assertions about variables in another procedure. 
Most definitely this would provide a better experience using the language. 
In a similar manner we can create more interesting programs if we have arrays, or atleast some sort of generic-collection, which we can operate on.

\subsubsection{Type system}
A typesystem would also be a good extension for better usability. 
It would allow us for having different types stored in variables, and if coupled with the other extension arrays also, which could reduce a lot of repeated code. 
Furthermore additional types could eliminate a lot of ``generic'' assertions. 
An example of this would be a type \textit{Nat} over the natural numbers, which would eliminate the necessity of checks such as $x \ge 0$. 
Such types would allow us to fix our faulty implementation of quantifiers in the interpreter as well, by allowing only certain types to be quantified. 
And although bruteforcing all values of a bound integer would still be extremely poor performace wise it would be a solution to our problem. However, bruteforcing should probably not be used, but the type system definitely opens up possibilities.

\subsubsection{PER-logic for Information Flow Control}
As mentioned multiple times, this project initially arose to make way for an implementation of the \textit{Partial Equivalence Relation} logic for information flow control\cite{Filinski-Jensen-Larsen:Unpublished-IFC}. 
The idea behind this is to prove properties of information flow, similarly to how we have been able to prove properties about simple \textit{While} constructs. 
From our assessment we find that the project is ready, or at least close to ready, to try to include this program logic. 
However, its remains unbeknownst whether we can generate verification conditions for the logic.
