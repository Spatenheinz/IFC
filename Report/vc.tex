%- snak om Weakest precondition, i en figur?
% the loosest precondition. Q is wp if {P}S{R} if and only if P=>Q. The least requirement for guaranteeing that R holds after S.
% There is only one wp. If Q and Q' are both wp, then {Q'}S{R} iff Q'=> Q and {Q}S{R} iff Q=>Q', so Q=Q', thus the wp is unique. (wiki)
%			wp vs sp? : {P}S{R} iff slp P c => R, meaning is is the strongest postcondition, ie if Q is sp then {P}S{R} if and only if Q => R. (2.pdf)

% verification conditions

% - Beskrive de vigtige af dem?
% assign, seq, while
In the previous section we presented Hoare Triples and how they can be used to ``assign meaning to programs''. However, it might not always be possible that the Precondition is known. In such a case, we can use Weakest Precondition Calculus (denoted $WP$), which essentially states:
$$
 \{WP(S,Q)\}S\{Q\}
$$
That is, we can use a well-defined calculus to find the weakest (least restrictive) precondition that will make $Q$ hold after $S$. By this calculus, which we present in this section, validation of Hoare Triples can be reduced to a logical sentence, since Weakest Precondition calculus is functional compared instead of realational as the Hoare logic.
That is, by finding the weakest precondition, we have a condition that can be used to verify the program, and that is called \textit{verification condition generation}.

Below the structure for computing the weakest liberal precondition for the different constructs is shown.
\begin{align*}
	WLP(\texttt{skip}, Q) &= Q \\
	WLP(x:=e,Q) &= \forall y, y = e \Rightarrow Q[x \leftarrow y] \\
	WLP(s_1;s_2, Q) &= WLP(s_1, WLP(s_2, Q)) \\
	WLP(\texttt{if } e \texttt{ then } s_1 \texttt{ else } s_2, Q) &= (e \Rightarrow WLP(s_1, Q)) \land (\neg e \Rightarrow WLP(s_2, Q)) \\
	WLP(\texttt{while } e \texttt{ invariant } I \texttt{ do } s, Q) &= 
		I \land \\
    &\quad \forall x_1, ..., x_k, \\
    &\quad (((e \land I) \Rightarrow WLP(s, I)) \land (( \neg e \land I) \Rightarrow Q))
       [w_i \leftarrow x_i] \\
	&\quad \text{where } w_1, ..., w_k \text{ is the set of assigned variables in} \\
  &\quad \text{statement } s \text{ and } x_1, ..., x_k \text{ are fresh logical variables.}
\end{align*}

% TODO: write something about the above?

% hvad med for total correctness?
% to prove termination of while loop we need variant
% wlp vs wp: partial correctness by ignoring termination. (1) invariant must hold at the start of the loop, (2) the invariant and the loop condition is enough to find the weakest precondition necessary to re-establish the loop invariant, (3) if and when the loop terminates using the invariant and the fact that the loop condition is false is enough to establish the required postcondition (wiki)
The Hoare logic can help us prove correctness, but does not guarantee termination of loops. To verify that a program terminates, we need a stronger assertion, in form of a loop variant.
The loop variant is an expression that decreases with each iteration of a loop, for example in the \textit{while}-loop from our example program $q$ is the variant, as can be seen in line 8 of the code (see code listing \autoref{figure:mult}).
To express the logic of using a variant for \textit{while}-loops, we use the following modified syntax.
$$
	\frac{
		\{I \land e \land v = \xi \} s \{I \land v \prec \xi \} \quad wf(\prec)
	}{
		\{I\} \texttt{ while } e \texttt{ invariant } I 
          \texttt{ variant } v, \prec \texttt{ do } s \{I \land \neg e\}
	}
$$

Now the weakest liberal precondition does not prove termination. If we want to prove termination in addition to the partial correctness obtained from \textit{wlp}, we need a \textit{weakest precondition} which is much like \textit{wlp}, but require that \textit{while}-loops have a loop variant. 
This makes it possible to prove termination, and is the difference between partial and total correctness.

The structure for computing the weakest preconditions for the constructs for total correctness is much like the one for computing weakest liberal precondition, except for the structure of \textit{while}-loops, which can be seen below.

\begin{align*}
	WP\left(
     \begin{array}{c}
     \texttt{while } e \texttt{ invariant } I \\
     \texttt{ variant } v, \prec \texttt{ do } s
     \end{array}
    , Q \right) 
    &= 
		I \land \\
    &\quad \forall x_1, ..., x_k, \xi, \\
    &\quad \quad (((e \land I \land \xi = v) \Rightarrow WP(s, I \land v \prec \xi)) \\
    &\quad \quad \quad \land ((\neg e \land I) \Rightarrow Q)) [w_i \leftarrow x_i] \\
	&\quad \text{where } w_1, ..., w_k \text{ is the set of assigned variables in} \\
  &\quad \text{statement } s \text{ and } x_1, ..., x_k, \xi \text{ are fresh logical variables.}
\end{align*}

%- gennemg√• det i eksemplet
% hvert fald for noget af eksemplet ?

% Sound og Complete?
%   - Soundness:
%				If {P}S{Q} can be derived, then {{P}}S{{Q}} holds
%				Any derivable triple is valid
%   - Completeness:
%       If {{P}}S{{Q}} holds, then {P}S{Q} can be derived
%				If the language is expressive enough, any valid triple {P}s{Q} can be derived


