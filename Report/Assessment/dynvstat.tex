Besides the QuickCheck and blackbox testing, we use example programs to check the quality of our implementation.
In this subsection we present some of the example programs written for testing, and describe how and why they are interesting.
Next we set forth the experiments that we conduct using the programs as input to both the \textit{Evaluator} and the \textit{VC generator}.
Finally we explain how we compare dynamic execution to static verification of the programs.

\paragraph{Example programs.}
% What example programs have we written and why? (some examples)
% TODO: comment on the necessity of variants. We did not find programs that actually need a variant.


\paragraph{Experiments with example programs.}
% TODO: think about the difference between a program with insufficient assertions resulting in a falsifiable verification condition, and a wrongly generated verification condition that is (mistakenly) falsifiable.


\paragraph{Provable with VC generation ensures successful evaluation.}
% Provable => true in evaluation, but not necessarily the other way around
Another important property on the relation between the dynamic execution of a program via the evaluator and the static proof of said program, is that if we can correctly prove the correctness of a program, then the dynamic evaluation should also hold. It is important to note that the implication does not hold in the other direction. The reason for this is that we might not have provided strong enough assertions to satisfy the generated formula, whilst the dynamic execution, might not need it to be correct.

If we take a closer look at the multiplication example previously.
% \lstinputlisting{Examplecode/mult.ifc}
\begin{lstlisting}
vars: [q,r]
requirements: {q >= 0 /\ r >= 0}
<!=_=!>
res := 0;
$a := q;
while (q > 0) ?{res = ($a - q) * r /\ q >= 0} !{q} {
      res := res + r;
      q := q - 1;
};
#{res = $a * r};
\end{lstlisting}
We have previously argued that the code is correct and can correctly be proved by Z3, but if we relax some of the assertions in the program, this will no longer be the case.
Instead of the loop-invariant \verb|?{res = ($a - q) * r /\ q >= 0}| consider the invariant \verb\?{res = ($a - q) * r}\ in this case Z3 will no longer be able to prove the correctness of said program. The generated formula looks as follows:
\begin{lstlisting}[mathescape=true]
$\forall q, r. \; (q \geq 0 \land r \geq 0) \Rightarrow$
$ \quad \forall res_{3}. \; res_{3} = 0 \Rightarrow$
$\quad \quad \forall \$a. \; \$a = q \Rightarrow$
$\quad \quad \quad (res_{3} = (\$a - q) * r \land q \geq 0)$
$\quad \quad \quad \; \land \forall q_{2}, res_{2}, \xi_{1}.$
$\quad \quad \quad \quad (q_{2} > 0 \land res_{2} = (\$a - q_{2}) * r \land \xi_{1} = q_{2}) \Rightarrow$
$\quad \quad \quad \quad \quad \forall res_{1}. \; res_{1} = res_{2} + r \Rightarrow$
$\quad \quad \quad \quad \quad \quad \forall q_{1}. \, q_{1} = q_{2} - 1 \Rightarrow$
$\quad \quad \quad \quad \quad \quad \quad (res_{1} = (\$a - q_{1}) * r \land 0 <= \xi_{1} \land q_{1} < \xi_{1})$
$\quad \quad \quad \land ((q_{2} \leq 0 \land res_{2} = (\$a - q_{2}) * r) \Rightarrow res_{2} = \$a * r)$
\end{lstlisting}
It becomes quite apparant that the invariant is no longer strong enough to be proved, since the restriction on $q_{2}$ is too weak. The two first conjuctions line 4 and line 5-9, will be true, given that $q_{2} = -3, res_{2} = 6, \$a = 0, r = 2 $.
In the last term
$(q_{2} \leq 0 \land res_{2} = (\$a - q_{2}) * r) \Rightarrow res_{2} = \$a * r$
, the RHS of the implication, will be true as
$(-3 \leq 0 \land 6 = 3 * 2)$, giving a false term.
Once again we can verify that our program acts correctly, by doing the same modification to the whyML program in \autoref{fig:whyml}. In this case the proof will as expected give a falsifiable counter-example. By this, we have a good certainty that our implementation is correct.
\\~\\
We test that whenever we can prove the correctness of an IFC program, the result will be correct. But ideally we would also want to be able to generate programs and test this using QuickCheck. However this is quite a complex situation, since we need to be able to have a strong enough loop-invariant to prove the correctness of the program. As of yet, we have not been succesful in implementing such a property-test.
