% something about evaluation
% What results do we get? (more in-depth than in the intro to the section)
In this section we give a collective assessment


%From the result presented in this Section, we have a fairly good solution, and our program actually works as intended on the example programs.
%In fact most of the problems that still persists in the code is related to the tests, which could be of better quality. Despite this the Quickcheck tests have been useful in finding subtle bugs.
% *** Failed! Falsified (after 4 tests):
%         Assign "c" (ABinary Mod (IntConst (-3)) (IntConst 0))
%         Use --quickcheck-replay=775220 to reproduce.
%         Use -p '/Eval ~ VC-SAT/' to rerun this test only.

%%% Hvad vil vi assesse? %%%
\subsubsection{Correctness}
% does our implementation work as expected
Through our testing strategy, we have found that our code is correct.


\subsubsection{Completeness}
% Do we support all the things we set out to?

\subsubsection{Robustness}
% Can our code fail

We have found bugs, such as the weird thing where modulo 0 is not an error in Z3.

\subsubsection{Maintainability}
As mentioned this project sould serve as a base, thus we have valued maintainability and extensibility highly. We have done so through the following abstractions. Firstly we are using monad-transformers to enforce seperation of concern. For the evalutor, we have even defined the \textit{Eval} type in terms of \textit{RWST} even though we only uses the \textit{State}-transformer and underlying Either monad. We do so since we highly anticipate that the other monadic effects will be useful in the future, such as being able to print (using writer).
Furthermore, the multistage approach, for generating verification conditions should also allow for easier extending possible SMT-backends.
In the current solution we only support \textit{Z3}, but allowing for the other SBV supported solvers, should be trivial.
But because we generate the verification condition (which barebones are a simple ADT) in a seperate state it should not be too cumbersome to allow for other backends.
\\~\\
In terms of extending the language with new constructs we consider the following cases.
\begin{itemize}
  \item If the construct can syntacticaly be reduce to one of the statements already defined, then only the parser would need to change.
  \item New statements, will require implementation in the parser, evaluator and the verification condition generator, but will most likely, not have to modify anything in the SBV API.
  Since the (toplevel) first order logic is already fully defined.
  Although this should never have to modify the already defined constructs.
  \item New types such as collections would require additions in all module but should not add too much extra complexity as to what new statements would.
  \item Adding a type-system would be a very useful addition, but will most likely be one of the biggest changes. As it would probably require additions to the constructors of the AST, or for an additional typed-AST and in this case the code for the already working parts would have to be modified.
\end{itemize}
All in all, we find that the code is maintainable and extendable, but some extensions will require some overhaul of the code.
% Can we easily extend

%Expression problem??

% unbounded integers pose a problem
% forall and exists in assertions

% NOTE: nogle gange timer while out meh

% parser

% evaluator

% vc generator

% putting them together
% TODO: where to talk about the results of these example programs in depth?
