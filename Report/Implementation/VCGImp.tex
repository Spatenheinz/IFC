\subsection{Verification Condition Generator}
The verification condition generator, uses the weakest precondition calculus to construct the condition, or weakest liberal precondition (if while has no specified variant). Like the approach in the evaluator we want to be able to chain the actions and include a state and reader environment in the construction of the verification condition.

\begin{lstlisting}
type Counter = M.Map VName Count
type Env = M.Map VName VName
type WP a = StateT Counter (ReaderT Env (Either String)) a
\end{lstlisting}

The Counter state is used to give unique names to variables. The purpose of the reader environment is to resolve variable substitution in the formula generated from the weakest preconditions.
\\~\\
As described in \cref{sec:vcg}, we use the quantified rule for assignment, when encountering assignments, to easily handle multiple occurences of the same variable. When developing the code for the VC generator our initial approach tried to minimize the number of times we had to resolve condition $Q$, but our approach to this showed failed. The working solution on the other hand is naive.

\subsubsection{Failed attempt}\footnote{should this even be included?}
As mentioned we tried to minimize the number of times we had to traverse condition $Q$. The initial approach tried to resolve $Q$ only after the entire formula were build. This would allows for a sentence with all names resolved in only two passes, one over the imperative language AST and one over the structure of the formula. The approach was intended to build up a map as such, where \verb\VName\ is an identifier:

\begin{lstlisting}
type Env1 = M.Map VName [VName]
\end{lstlisting}

Whenever encountering a variable we would add a unique identifier to its value-list along with extending $Q$ by the WP rules, as such:

\begin{lstlisting}
missing
\end{lstlisting}

The result of running WP would then give a partially resolved formula, meaning that all the bound variables introduced in the quantifiers of the assignment rule will be correctly resolved. All other variables, would have their original name, and hence at this point be free.

The second traversal will the be on this partly resolved formula. Whenever encountering a variable $x$, we would then look it up in the Map, and then replace $x$ with the head of the list, since this must have been the last introduced bound variable. When encountering a quantifier (except for the first for each free variable), we would then ``pop'' the head of the appropriate list, as any later occurence of $x$ would be substituted with this newly found variable. The problem with this approach is how the AST for First Order Logic formula is constructed. Consider the following example:
\begin{lstlisting}
r := 5
r := r + 10
\end{lstlisting}
which after popping $r_{1}$ of the list would then look like
\begin{lstlisting}[mathescape=true]
$\forall r_{1}\; . \; r_{1} = 5 => \forall r_{2} \; . \; r_{2} = r + 10 => true$
\end{lstlisting}
This means that we can no longer substitute in $r_{1}$ when encountering the next $r$ in $r_{2} = r + 10$. On the other hand if we dont ``pop'' as soon as $r_{2}$ is encountered we have no information on when to do so, as it is not necessary the case that there appears an $r$ in the equality before the implication. When this problem arose we turned to the naive solution.

\subsubsection{Successful attempt}
The second and current approach is to resolve $Q$ whenever we encounters an assignment. We generate the forall as such:
\begin{lstlisting}
wp (Assign x a) q = do
    x' <- genVar x
    q' <- local (M.insert x x') $ resolveQ1 q
    return $ Forall x' (Cond (RBinary Eq (Var x') a) .=>. q')
\end{lstlisting}
We make a new variable (by generating a unique identifier, based on the State), then we proceed to resolve $q$ with the new environment, such that every occurence of variable $x$ will be substituted by the newly generated variable $x'$.
The \verb\Aexpr\ which $x$ evaluates to should not be resolved yet, as this will potentially depend on variables not yet encounted.
Ghost variables on the other hand are easy to resolve as they need not be substituted, because of immutability.
\\~\\
The current version does not enforce the formula to be closed, although it will be necessary in the generation of symbolic variables. Although easily fixed by a simple new iteration over the AST of the formula, and checking if any non-ghost variable does not contain a \verb\#\, we find that since the formula is intended to be fed to the next stage in the compiler it is uneccesary to do so.

\subsubsection{While - invariants and variants}
The \texttt{while} statement has the most complicated Weakest Precondition. The code for computing wp for a \texttt{while}-loop is presented in \cref{fig:wpwhile}.
\begin{figure}[h]
\begin{lstlisting}
wp (While b inv var s) q = do
  st <- get
  (fa, var', veq) <- maybe (return (id,
                            Cond $ BoolConst True,
                            Cond $ BoolConst True)) resolveVar var
  w <- wp s (inv ./\. var')
  fas <- findVars s []
  let inner = fa (((Cond b ./\. inv ./\. veq) .=>. w)
                          ./\. ((anegate (Cond b) ./\. inv) .=>. q))
  env <- ask
  let env' = foldr (\\(x,y) a -> M.insert x y a) env fas
  inner' <- local (const env') $ resolveQ1 inner
  let fas' = foldr (Forall . snd) inner' fas
  return $ inv ./\. fas'
  where
    resolveVar :: Variant -> WP (FOL -> FOL, FOL, FOL)
    resolveVar var = do
      x <- genVar "variant"
      return (Forall x,
              Cond (Negate (RBinary Greater (IntConst 0) (Var x)))
               ./\. Cond (RBinary Less var (Var x))
             , Cond (RBinary Eq (Var x) var)
             )
\end{lstlisting}
\caption{Weakest precondition for \texttt{while}}
\label{fig:wpwhile}
\end{figure}

We have tried to make the code generic in terms existence of the variant to eliminate code duplication.
line 6-9, will generate the conditions needed for the variant.
In case no variant is defined we use that predicate-logic and conjuction forms a monoid with $\top$ as identity element, such that, we generate no new $\forall$-quantification, and have subformular $b \Rightarrow WP(s,b)$.
Is there a variant, we generate the equality $\xi = v$, along with the well-founded relation for unbounded integers. This approach should translate pretty well, with possible other types that have a well-founded relation. The rest of the code simply checks which variables are assigned in the body of the while-loop, and generate a variable for each. Collectively this code will generate the weakest precondition for a while statement as per described in equation~\ref{eq:wpwhile}.
