\subsection{Parser}\label{sec:parser}
The internal AST is defined pretty close to the grammar in \autoref{table:grammar} and can be seen in Appendix \ref{}.
For the parsing of a program we use the parser combinator library MegaParsec, which means we have to eliminate ambiguity in the grammar presented.
We do so in two different ways.
For arithmetic operators and boolean operators, we make use of the expression parser defined in \verb\Control.Monad.Combinators.Expr\.
This makes handling operators, precedence and associativity easy, however for the parsing of first order logic in asssertions, this approach did not work. Instead we have to modify the grammar. as such:
\begin{figure}
\includegraphics{write up the grammar}
\end{figure}
\\~\\
We further introduces some syntactic sugar in the grammar such as ``if c {s};'' which will be desugared into ``if c {s} else {skip};''.
For other parts of the grammar, which could have easily been syntactic sugar, such as implication and exist, we use the unsugared constructs. Although this introduces more code, the intent is to make the code easier to reason about in terms of the semantics. Furthermore it reads better in the output of the vc generator, and by knowledge of the predicate transformer semantics . This at least has made the development process easier. Ideally this could be alleviated by a more comprehensible pretty-printer, but at the current moment, we settle for a slightly bigger AST, and as of now this does not add much overhead to the other parts of the program, although this might be rethought in the future.
\\~\\
Another point that is worth mentioning is how we handle illegal uses of ghost variables.
An illegal use of a ghost variable is a semantical, that is a ghost variable can be declared and occur in the assertion language, but never appear elsewhere in the program logic.
However, we have gone with an approach which will simply fail to parse if a ghost variable appears anywhere not allowed.
We do so by adding a reader monadtransformer, to the parser type.

\begin{lstlisting}{haskell}
type Parser = ParsecT Void String (ReaderT Bool Identity)
\end{lstlisting}

The boolean value in this environment will tell if the next parser (by the use of \verb\local\) must allow for parsing ghost variables. Which will certainly only happen in assertions.
We find that eliminating illegal usecases for ghosts in the parser is far preferable than doing so in both the VC-generator and the evaluator, however this restricts us from generating ghost variables in our Quickcheck generation of statements.
% Having a local environment denoting if something is legal or not showed to be very useful, when handling assertions in the evaluator. An explanation of this can be seen in \autoref{sec:evaluator}.

TODO: ADD SOMETHING ABOUT FACTORIZATION
