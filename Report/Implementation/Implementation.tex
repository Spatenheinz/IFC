\section{Implementation}\label{sec:implementation}
IFC is yet to be more than just a toy-language, however in the design of the language and the actual compiler, we have tried to focus making the code modular and easy to extend.
Currently the program consists of 4 parts.
\begin{enumerate}
  \item Parser
  \item Evaluator
  \item Verification Condition Generator
  \item External SMT-solver API
\end{enumerate}
Each part will carry out a task for the program. There is no explicit dependency between any of these parts. Though the main interface is setup to the following tasks:
\begin{enumerate}
  \item Extract the Abstract Syntax Tree generated in the Parser
  \item Run a program with an initial store
  \item Extract the formula by Verification Condition Generator
  \item Run the formular through an external prover (Z3).
\end{enumerate}
\autoref{sec:guide} explains how each of these are used. In the following section we describe how each the 4 program parts are implemented.

\input{Implementation/parser.tex}

\input{Implementation/evaluator.tex}

\input{Implementation/VCGImp.tex}

\input{Implementation/api.tex}

\subsection{Interface for proofs}
As may have been apparant from the example programs presented earlier in this report, we requires each IFC program to have a header that looks as follows:
\begin{lstlisting}
vars: [ <variables> ]
requirements: { <preconditions> }
<!=_=!>
\end{lstlisting}
where <variables> describes the variables, which is initially in the ``store'' and <preconditions> is an assertion, which specifies a condition that should hold before the program starts.
The header does not provide new for the evaluator, (although we prepend the requirement to the program as an assertion), but it enables us to make more generic proofs about said programs.
In the current state, there is no procedures in IFC, which makes it difficult to reason about the input of variables, when trying to prove the weakest precondition, hence why we define said header.
The inspiration comes from how the whyML language defines procedures. A whyML program equivalent to the mult.IFC program looks as follows:
\begin{lstlisting}
module Mult

  use int.Int
  use ref.Refint

  let mult (&q : ref int) (r: int) : int
    requires { q >= 0 && r >= 0 }
    =
    let ref res = 0 in
    let ghost a = q in
    while q > 0 do
      invariant { res = (a - q) * r && q >= 0}
      variant { q }
      decr q;
      res += r
    done;
    assert { res = a * r };
    res
end
\end{lstlisting}
It is possible for why3 to generate a vector of input variables and then a precondition for each the \verb\requires\, such that $\forall x_{1}...,x_{n}. \; requires => WP(body, ensures)$.
That is whenever the requires holds, then the weakest precondition of the body should hold, where ensures states the postcondition.
Notice that our setup is very similar to this, but since we dont have any return values, we dont really need the ensures, since this might as well be part of the actual program.\footnote{is this clear if you dont know whyML?}
