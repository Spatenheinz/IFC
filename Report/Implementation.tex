\section{Implementation}
IFC is yet to be more than just a toy-language, however in the design of the language and the actual compiler, we have tried to focus making the code modular and easy to extend.
Currently the program consists of 4 parts.
\begin{enumerate}
  \item Parser
  \item Evaluator
  \item Verification Condition Generator
  \item External SMT-solver API
\end{enumerate}
Each part will carry out a task for the program. There is no explicit dependency between any of these parts. Though the main interface is setup to the following tasks:
\begin{enumerate}
  \item Extract the Abstract Syntax Tree generated in the Parser
  \item Run a program with an initial store (TODO!!!! REALLY NEED THIS)
  \item Extract the formula by Verification Condition Generator
  \item Run the formular through an external prover (Z3).
\end{enumerate}
Section ?? explains each of these are used. In the following section we describe how each the 4 program parts are implemented.

\subsection{Parser}
For the parsing stage of the compiler we use the parser combinator library MegaParsec. Most of the parsing is fairly standard, however the following is noticable.
\\~\\
In the previous sections we described the syntax and the semantics of IFC, in that section we describe only a few of the semantics and state some operators which is simply syntactic sugar for the ones presented in the semantics. However, for certain parts of the actual AST, we use the unsugared constructs, this is mainly seen in the first order logic, in terms of the \verb\exists\ and implication. This is purely, because it reads better in the output of the vc generator. This at least has made the development process easier. Ideally this could be alleviated by a more comprehensible pretty-printer, but at the current moment, we settle for a slightly bigger AST, and as of now this does not add much overhead to the other parts of the program, although this might be rethought in the future.
\\~\\
Another point that is worth mentioning is how we handle illegal uses of ghost variables.
An illegal use of a ghost variable is a semantical, that is a ghost variable can be declared and occur in the assertion language, but never appear elsewhere in the program logic.
However, we have gone with an approach which will simply fail to parse if a ghost variable appears anywhere not allowed.
We do so by adding a reader monadtransformer.

\begin{lstlisting}{haskell}
type Parser = ParsecT Void String (ReaderT Bool Identity)
\end{lstlisting}

The boolean value in this environment will tell if the next parser must allow for parsing ghost variables. Which will certainly only happen in assertions.
We find that eliminating illegal usecases for ghosts in the parser is far preferable than doing so in both the VC-generator and the evaluator.

\subsection{Evaluator}
The evaluator follows directly from the semantics presented in section ??. That is the intial store provided to the evalutor will be modified over the course of the program according to the semantics. As of now the type of the evaluator is quite bloated compared to what is actually used. We define the \verb\Eval\ type as follows such:

\begin{lstlisting}
type STEnv = M.Map VName Integer
type Eval a = RWST () () STEnv (Either String) a
\end{lstlisting}

At the moment there is no use for reader, however when the language in the future is extended to have procedures the reader monad will be a natural choice for the scoping rules of said procedures.
Likewise there is no real use of the writer monad yet. Again this is for proofing for a future where the language supports some sort of IO, and atleast being able to print would be nice.
The store described in section ?? is kept in the State. The Store is simply a map from VName to Integers. We want the store to be a State as the store after one monadic action should be chained with the next monadic action. This ensures that all variables are in scope for the rest of the program and easily allows for mutable variables.
Duely note that ghost variables will also reside in this environment but will not be mutable or even callable as previously explained.
We make use of the error monad to resolve any runtime-errors that would arise, that is if a violation is done, a ghost is assigned, a variable is used before it is defined or if undefined behaviour arises such as division by 0.
\\~\\
Each non-terminal in the grammar are resolved by different functions which all operate under the $Eval$ monad, which allows for a clean and modular monadic compiler.
\\~\\
One important note about the interpreter is that we have no good way of checking assertions which includes qunatifiers. The reasons is that we wanted to support arbitrary precision integers, however this means that we at the moment has no feasible way to handle these. A potential solution would be to generate a symbolic reprensentation of the formula and try to satisfy it by using an external prover. Though the interpreter would then also require external dependencies. Hereby assertions with quantifiers do nothing at the moment, while non-qunatified assertions, will be evauluated as per the operational semantics (At the moment they do nothing).

\subsection{Verification Condition Generator}
The verification condition generator, uses the weakest liberal precondition, or weakest precondition (if while contains a variant). Again we want to be able to chain the actions and include a state and reader environment.

\begin{lstlisting}
type Counter = M.Map VName Count
type Env = M.Map VName VName
type WP a = StateT Counter (ReaderT Env (Either String)) a
\end{lstlisting}

The Counter state is used to give unique names to variables. Whereas we want the reader environment to resolve variable substitution in the formula generated from the weakest preconditions.

As described in section ??, we use the forall rule, when encountering assignments. In the development process we considered two different approaches to resolve this.

\subsubsection{First approach}
The initial approach tried to resolve $Q$ only after the entire formula were build. This would allows for WLP to be resolve in only two passes, one over the imperative language AST and one over Assertion Language AST in the formula. The approach was intended to build up a map as such, where \verb\VName\ is an identifier (String):

\begin{lstlisting}
type Env1 = M.Map VName [VName]
\end{lstlisting}

Whenever encountering a variable we would add a unique identifier to its value-list along with extending $Q$ by the WP rules, as such:

\begin{lstlisting}
missing
\end{lstlisting}

The result of running WP will then give a partially resolved formula and the final state. When resolving ... Jeg t√¶nker lige.

\subsubsection{Second approach}
The second and current approach is to resolve $Q$ whenever we encounters a variable. We generate the forall as such:
\begin{lstlisting}
wp (Assign x a) q = do
    x' <- genVar x
    q' <- local (M.insert x x') $ resolveQ1 q
    return $ Forall x' (Cond (RBinary Eq (Var x') a) .=>. q')
\end{lstlisting}
We make a new variable (simply generating a unique identifier), then we proceed to resolve $q$ with the new environment, such that every occurence of $x$ will be substituted by $x'$. The \verb\Aexpr\ which $x$ evaluates to should not be resolved in this case, as this will potentially depend on variables not yet encounted.
\\~\\
This approach will go over the entire formula every time an assignment is made, which is quite inefficient, hence why the initial approach seemed better (and potentially still is, if we can make it work).
\\~\\
Because of their uniqueness ghost variables on the other hand is straight forward to resolve as we need no substitution.
\\~\\
Furthermore the current version does not enforce the formula to be closed, although it will be necessary in the generation of symbolic variables. This would easily be fixed by a simple new iteration over the AST of the formula, and checking if any non-ghost variable does not contain a \verb\#\.

\subsubsection{While - invariants and variants}
NOTICE WE HAVE A BUG:
If two assignments are done inside the while loop we cannot prove it.
otherwise it seem to work???

The \verb\while\ construct is the most complicated of the constructs. As previously mentioned, for partial correctness, we need atleast an invariant, and for full correctness also a variant. Thus we enfore the user to provide as a minimum the invariant.
If no invariant is provided an error is reported.
If an invariant is provided, we start by folding the (potentially many) invariants together by conjunction. We then handle the variant if any.
We do so by either generate a new \verb\invariant\ variable $x$, and return a \verb\Forall x\ function, if the variant is not present, we return \verb\id\, for monadic composition.
Then compute wlp for the body, and resolve the entire formula as explained in ??.

\subsection{proof-assistant API}
The proof-assistant API uses the SMT Based Verification library (SBV), which tries to simply symbolic programming in Haskell. The library is quite generic and extensive compared to what we use it for. Again this can be good in the future but is also a big dependency. We mostly make use of the higher level functions and dont mess with any of the internals. The code which generates a \verb\Predicate\ is simple, since the formula generated in the previous stage, will be a first order logic formula, which straight forwardly can be converted into SBV's types. For the entire highlevel logic we resolve it as simple as this:
\begin{lstlisting}
type SymTable = M.Map VName SInteger

fToS :: FOL -> SymTable -> Predicate
fToS (Cond b) st = bToS b st
fToS (Forall x a) st = forAll [x] $ \(x'::SInteger) ->
  fToS a (M.insert x x' st)
fToS (Exists x a) st = forSome [x] $ \(x'::SInteger) ->
  fToS a (M.insert x x' st)
fToS (ANegate a) st = sNot <$> fToS a st
fToS (AConj a b) st = on (liftM2 (.&&)) (`fToS` st) a b
fToS (ADisj a b) st = on (liftM2 (.||)) (`fToS` st) a b
fToS (AImp a b) st = on (liftM2 (.=>)) (`fToS` st) a b
\end{lstlisting}

And equally easy it is to resolve \verb\bexpr\ and \verb\aexpr\. Notice how this simply will generate a single collective predicate, instead of the often more used DSL like use of monadically generating quantified variables and constraints. The generated predicate will then try to be proved by the SBV function \verb\prove\, If the program can correctly be proved by the external SMT solver, the output will be \verb\Q.E.D.\, whereas if the formula cannot be proved, a falsifiable instance of the variables will be presented. For instance the output of the following program will obviously always be falsified.

\begin{lstlisting}
violate;
\end{lstlisting}

on the otherhand the previously shown multiplication example, will be proved.


- Why have we taken the approach we have. Multistage generation?
- Following is interesting:
  - quantifers
  - ghosts
  - while (invarianter og varianten)
- Ideally static and dynamic execution should give equivalent results.
- Testing
