\section{Implementation}
IFC is yet to be more than just a toy-language, however in the design of the language and the actual compiler, we have tried to focus making the code modular and easy to extend.
Currently the program consists of 4 parts.
\begin{enumerate}
  \item Parser
  \item Evaluator
  \item Verification Condition Generator
  \item External SMT-solver API
\end{enumerate}
Each part will carry out a task for the program. There is no explicit dependency between any of these parts. Though the main interface is setup to the following tasks:
\begin{enumerate}
  \item Extract the Abstract Syntax Tree generated in the Parser
  \item Run a program with an initial store (TODO!!!! REALLY NEED THIS)
  \item Extract the formula by Verification Condition Generator
  \item Run the formular through an external prover (Z3).
\end{enumerate}
Section ?? explains each of these are used. In the following section we describe how each the 4 program parts are implemented.

\subsection{Parser}
For the parsing stage of the compiler we use the parser combinator library MegaParsec. Most of the parsing is fairly standard, however the following is noticable.

In the previous sections we described the syntax and the semantics of IFC, in that section we describe only a few of the semantics and state some operators which is simply syntactic sugar for the ones presented in the semantics. However, for certain parts of the actual AST, we use the unsugared constructs, an example of this is the \texttt{exists} in the assertion language. This is purely, because it reads better in the output of the vc generator. This at least has made the development process easier. Ideally this could be alleviated by a more comprehensible pretty-printer, but at the current moment, ??? THIS IS GARBAGE.

Another point that is worth mentioning is how we handle illegal uses of ghost variables.
An illegal use of a ghost variable is a semantical, that is a ghost variable can be declared and occur in the assertion language, but never appear elsewhere in the program logic.
However, we have gone with an approach which will simply fail to parse if a ghost variable appears anywhere not allowed.
We do so by adding a reader monadtransformer.

\begin{verbatim}
type Parser = ParsecT Void String (ReaderT Bool Identity)
\end{verbatim}

The boolean value in this environment will tell if the next parser must allow for parsing ghost variables. Which will certainly only happen in assertions.
We find that eliminating illegal usecases for ghosts in the parser is far preferable than doing so in both the VC-generator and the evaluator.

\subsection{Evaluator}
The evaluator follows directly from the semantics presented in section ??. That is the intial store provided to the evalutor will be modified over the course of the program according to the semantics. As of now the type of the evaluator is quite bloated compared to what is actually used. We define the \verb\Eval\ type as follows such:

\begin{verbatim}
type STEnv = M.Map VName Integer
type Eval a = RWST () () STEnv (Either String) a
\end{verbatim}

At the moment there is no use for reader, however when the language in the future is extended to have procedures the reader monad will be a natural choice for the scoping rules of said procedures.
Likewise there is no real use of the writer monad yet. Again this is for proofing for a future where the language supports some sort of IO, and atleast being able to print would be nice.
The store described in section ?? is kept in the State. The Store is simply a map from VName to Integers. We want the store to be a State as the store after one monadic action should be chained with the next monadic action. This ensures that all variables are in scope for the rest of the program and easily allows for mutable variables.
Duely note that ghost variables will also reside in this environment but will not be mutable or even callable as previously explained.
We make use of the error monad to resolve any runtime-errors that would arise, that is if a violation is done, a ghost is assigned, a variable is used before it is defined or if undefined behaviour arises such as division by 0.

Each non-terminal in the grammar are resolved by different functions which all operate under the $Eval$ monad, which allows for a clean and modular monadic compiler.

Ideally the assertions, should actually work. At the moment they do nothing.

% \inference[Assign]{ \\ \cmd{\lttdots} \\ \lra{x,\sigma} }{〈conclusion〉}

\subsection{Verification Condition Generator}
The verification condition generator, uses the weakest liberal precondition, or weakest precondition (if while contains a variant). Again we want to be able to chain the actions and include a state and reader environment.

\begin{verbatim}
type Counter = M.Map VName Count
type Env = M.Map VName VName
type WP a = StateT Counter (ReaderT Env (Either String)) a
\end{verbatim}

The Counter state is used to give unique names to variables. Whereas we want the reader environment to resolve variable substitution in the formula generated from the weakest preconditions.

As described in section ??, we use the forall rule, when encountering assignments. In the development process we considered two different approaches to resolve this.

\subsubsection{First approach}
The initial approach tried to resolve $Q$ only after the entire formula were build. This would allows for WLP to be resolve in only two passes, one over the imperative language AST and one over Assertion Language AST in the formula. The approach was intended to build up a map as such, where \verb\VName\ is an identifier (String):

\begin{verbatim}
type Env1 = M.Map VName [VName]
\end{verbatim}

Whenever encountering a variable we would add a unique identifier to is value-list. The result of running WP will then give a partially resolved formula and the final state. When resolving ... Jeg tænker lige.

\subsection{Second approach}
The second approach and current approach is to resolve $Q$ whenever we go over

\subsection{proof-assistant API}

- Why have we taken the approach we have. Multistage generation?
- Following is interesting:
  - quantifers
  - ghosts
  - while (invarianter og varianten)
- Ideally static and dynamic execution should give equivalent results.
- Testing
