%- snak om Weakest precondition, i en figur?
% the loosest precondition. Q is wp if {P}S{R} if and only if P=>Q. The least requirement for guaranteeing that R holds after S.
% There is only one wp. If Q and Q' are both wp, then {Q'}S{R} iff Q'=> Q and {Q}S{R} iff Q=>Q', so Q=Q', thus the wp is unique. (wiki)
%			wp vs sp? : {P}S{R} iff slp P c => R, meaning is is the strongest postcondition, ie if Q is sp then {P}S{R} if and only if Q => R. (2.pdf)

% verification conditions

In the previous section we presented Hoare Triples and how they can be used to ``assign meaning to programs''. However, it might not always be possible that the Precondition is known. In such a case, we can use Weakest Precondition Calculus (denoted $WP$), which essentially states:
$$
 \{WP(S,Q)\}S\{Q\}
$$
That is, we can use a well-defined calculus to find the weakest (least restrictive) precondition that will make $Q$ hold after $S$. By this calculus, which we present in this section, validation of Hoare Triples can be reduced to a logical sentence, since Weakest Precondition calculus is functional compared to the relational nature of Hoare logic.
By computing the weakest precondition, we get a formula of first-order logic that can be used to verify the program, and that is called \textit{verification condition generation}.

\subsubsection{Weakest Liberal Precondition}
Below the structure for computing the weakest liberal precondition for the different constructs is shown.
\begin{align*}
	WLP(\texttt{skip}, Q) &= Q \\
	WLP(x:=e,Q) &= \forall y, y = e \Rightarrow Q[x \leftarrow y] \\
	WLP(s_1;s_2, Q) &= WLP(s_1, WLP(s_2, Q)) \\
	WLP(\texttt{if } e \texttt{ then } s_1 \texttt{ else } s_2, Q) &= (e \Rightarrow WLP(s_1, Q)) \land (\neg e \Rightarrow WLP(s_2, Q)) \\
	WLP(\texttt{while } e \texttt{ invariant } I \texttt{ do } s, Q) &= 
		I \land \\
    &\quad \forall x_1, ..., x_k, \\
    &\quad (((e \land I) \Rightarrow WLP(s, I)) \land (( \neg e \land I) \Rightarrow Q))
       [w_i \leftarrow x_i] \\
	&\quad \text{where } w_1, ..., w_k \text{ is the set of assigned variables in} \\
  &\quad \text{statement } s \text{ and } x_1, ..., x_k \text{ are fresh logical variables.}
\end{align*}

% TODO: write something about the above?
The rules are somewhat self-explanatory, but we would like to go through some rules which have been important for our work.

\paragraph{Assignments.}
The rule for computing weakest liberal precondition for assignments says that for all variables $y$ where $y = e$, we should exchange $x$ in $Q$ with $y$. That is, we exchange all occurrences of $x$ with the value that we assign to $x$.

\paragraph{Sequence.}
For finding the \textit{wlp} of a sequence of statements $s_1;s_2$, we need to first find the \textit{wlp} $Q'$ of $s_2$ with $Q$, and then compute the \textit{wlp} of $s_1$ with $Q'$. This shows how we compute the weakest liberal precondition using a bottom-up approach.

\paragraph{While-loops.}
To compute the \textit{wlp} of a while loop we have to eensure that the loop invariant holds before, inside, and after the loop. That is why the first condition is simply that the invariant $I$ must evaluate to $true$.
Next we need to assert that no matter what values the variables inside the loop have, the invariant and loop condition will hold whenever we go into the loop, and the invariant and negated loop condition will hold when the loop terminates.
For these variables, we must also exchange all the occurrences in the currently accumulated weakest liberal precondition $Q$.

\subsubsection{Weakest Precondition}
% hvad med for total correctness?
% to prove termination of while loop we need variant
% wlp vs wp: partial correctness by ignoring termination. (1) invariant must hold at the start of the loop, (2) the invariant and the loop condition is enough to find the weakest precondition necessary to re-establish the loop invariant, (3) if and when the loop terminates using the invariant and the fact that the loop condition is false is enough to establish the required postcondition (wiki)
Right now, the Hoare logic can help us prove partial correctness, but does not guarantee termination of loops. We would like to be able to prove total correctness, meaning we want to prove termination. To verify that a program terminates, we need a stronger assertion, in form of a loop variant.
The loop variant is an expression that decreases with each iteration of a loop, for example in the \textit{while}-loop from our example program $q$ is the variant, as can be seen in line 8 of the code (see code listing \autoref{figure:mult}).
To express the logic of using a variant for \textit{while}-loops, we use the following modified syntax.
$$
	\frac{
		\{I \land e \land v = \xi \} s \{I \land v \prec \xi \} \quad wf(\prec)
	}{
		\{I\} \texttt{ while } e \texttt{ invariant } I 
          \texttt{ variant } v, \prec \texttt{ do } s \{I \land \neg e\}
	}
$$

where $v$ is the variant of the loop, and $\xi$ is a fresh logical variable. $\prec$ is a well-founded relation, and because the data type consists of all unbounded integers, we use the well-founded relation:
$$x \prec y \quad = \quad x < y \land 0 \leq y $$
reference: (poly1.pdf)

Now the weakest liberal precondition does not prove termination. If we want to prove termination in addition to the partial correctness obtained from \textit{wlp}, we need a \textit{weakest precondition} which is much like \textit{wlp}, but require that \textit{while}-loops have a loop variant. 
This makes it possible to prove termination, and is the difference between partial and total correctness.

The structure for computing the weakest preconditions for the constructs for total correctness is much like the one for computing weakest liberal precondition, except for the structure of \textit{while}-loops, which can be seen below.

\begin{align*}
	WP\left(
     \begin{array}{c}
     \texttt{while } e \texttt{ invariant } I \\
     \texttt{ variant } v, \prec \texttt{ do } s
     \end{array}
    , Q \right) 
    &= 
		I \land \\
    &\quad \forall x_1, ..., x_k, \xi, \\
    &\quad \quad (((e \land I \land \xi = v) \Rightarrow WP(s, I \land v \prec \xi)) \\
    &\quad \quad \quad \land ((\neg e \land I) \Rightarrow Q)) [w_i \leftarrow x_i] \\
	&\quad \text{where } w_1, ..., w_k \text{ is the set of assigned variables in} \\
  &\quad \text{statement } s \text{ and } x_1, ..., x_k, \xi \text{ are fresh logical variables.}
\end{align*}

% What are the differences? explain!
We see that the difference between the computation of \textit{wp} and \textit{wlp} is the presence of the \textit{variant}. When given a variant expression $v$ for the loop, we add the assertion that this expression decreases with each iteration, using the logical variable $\xi$ to keep the old value of $v$ to compare with.

%- gennemgÃ¥ det i eksemplet
% hvert fald for noget af eksemplet ?
For our example program \texttt{mult.ifc}, we can compute the weakest precondition, as we have both a variant and an invariant in the while loop.
By applying the \textit{wp} rules on the example, we get the weakest precondition seen in \autoref{figure:wpmult}.

SKRIV LIDT MERE OM HVORFOR HER!

\begin{figure}[h]
\input{Background/multVC}
\caption{Weakest precondition of \texttt{mult.ifc}}
\label{figure:wpmult}
\end{figure}


% Sound og Complete?
%   - Soundness:
%				If {P}S{Q} can be derived, then {{P}}S{{Q}} holds
%				Any derivable triple is valid
%   - Completeness:
%       If {{P}}S{{Q}} holds, then {P}S{Q} can be derived
%				If the language is expressive enough, any valid triple {P}s{Q} can be derived


