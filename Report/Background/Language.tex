IFC is a small imperative programming language with a build in assertion language enabeling the possibility for statically verifying programs by the use of external provers.
The assertions also enables us to dynamically check the program during evaluation.
In this section we will present the syntax and semantics of both the imperative language and the assertion language.

% explain the following
% names: starts with a lowercase letter or underscore, can contain letters, digit, underscores


\begin{table}[h!]
% \centering
\input{Background/grammar}
\caption{Grammar of IFC}
\label{table:grammar}
\end{table}

% semantics of the language

TODO: update while to also include invariant.
\begin{table}[h!]
\centering
\input{Background/semantic}
\caption{Semantics for the \textit{while} language.}
\label{table:semantic}
\end{table}

TODO: add rules for while-loops with invariants and variants?

\cref{table:grammar} shows the grammar of IFC. In essence an IFC program is a statement with syntax in the C-family. The language is small, as the focus in this project has been to correctly being able to generate verification conditions for said programs.
In \cref{table:semantic} we show the semantics of the different statements.

Arithmetic expressions (\verb\aexpr\) follow the standard rules of precedence and associativity:
\begin{itemize}
  \item parenthesis
  \item negation
  \item Multiplication, division and modulo (left associative)
  \item Addition and subtraction (left associative)
\end{itemize}
where parenthesis binds tightest.

Likewise boolean expressions (\verb\bexpr\) follow the standard precedence rules:
\begin{itemize}
	\item negate (!)
	\item logical and (\&\&)
  \item logical or ($||$)
\end{itemize}


\begin{figure}
\lstinputlisting{Examplecode/basicmult.ifc}
\caption{Example program \texttt{mult.ifc}}
\label{figure:basicmult}
\end{figure}

\paragraph{Multiplication as an example.}
To show what the language is capable of, a small example program computing the multiplication of two integers $q$ and $r$ is presented in \cref{figure:basicmult}. Line 2 shows the syntax of assignments, lines $3$-$6$ shows the syntax of while loops, and the entire program is also a demonstration of sequencing statements.
For now, we leave out the assertions, but we will come back to this in \cref{sec:hoare}.

Now even though this small while language is very simple, it is still very interesting as base language for our project.
By creating an assertion language that can prove the correctness for programs written in this simple language, we can show that it is possible to prove termination and correctness of while loops, which are definitely the tricky part of this language.
Loops are specifically challenging because we cannot know whether they ever terminate. Furthermore the way a loop affects program variables is less see-through than for example the effects of an assignment.
Therefore it is desirable to be able to prove the correctness of such programs, and that is why this small language is well suited for the purpose.
