\textit{While} is a small imperative programming language with a built-in assertion language, enabeling the possibility of statically verifying programs by the use of external provers.
The assertions also enables us to dynamically check the program during evaluation.
In this section we will present the syntax and semantics of both the imperative language and the assertion language.

% explain the following
% names: starts with a lowercase letter or underscore, can contain letters, digit, underscores

\begin{table}[h!]
% \centering
\input{Background/grammar}
\caption{Grammar of IFC}
\label{table:grammar}
\end{table}

The language is simple, as the focus in this project has been to correctly generate verification conditions for said programs.
\cref{table:grammar} shows the grammar of \textit{While}. 
In essence, a \textit{While} program is a statement with syntax in the C-family. 
We require a program to have a \textit{header}, succeeded by one or more statements.
We leave out the syntax of the header in the grammar, but will describe it in detail in \cref{sec:interface}, where we explain why it is necessary as well.

% while loops
% assertions
The grammar is quite straight forward. 
One of the interesting program constructs are while loops, which consist of a loop condition, one or more variants, and zero or one variant, followed by a loop body. The reason for inclusion of loop invariants and variants will be apparent in \cref{sec:hoare}.
Another interesting construct is if statements, which can be constructed both with and without an else branch.
Finally assertion statements are of great importance for this project. An assertion is denoted by a hashtag and curly braces. We will explain more about assertions in \cref{sec:hoare} and \cref{sec:vcg}.

To resolve ambiguity it should be noted that arithmetic expressions (\verb\aexpr\) follow the standard rules of precedence and associativity:
\begin{itemize}
  \item Parentheses
  \item Negation
  \item Multiplication, division and modulo (left associative)
  \item Addition and subtraction (left associative)
\end{itemize}
where parentheses binds tightest. Likewise boolean expressions (\verb\bexpr\) follow the standard precedence rules:
\begin{itemize}
	\item negate (!)
	\item (\&\&) (right associative)
	\item ($||$) (right associative)
\end{itemize}
and the operators used in assertions follow the following precedence rule:
\begin{itemize}
	\item $\land$ (right associative)
	\item $\lor$ (right associative)
	\item $\forall$ and $\exists$
	\item $\Rightarrow$ (right associative)
\end{itemize}
where $\land$ binds tightest.

% semantics of the language
% NOTE: just for commands. Should there be anything about arithmetic and boolean expressions?
In \cref{table:semantic} we show the semantics of the different statements in \textit{While}.
The program variables are kept in a store, mapping variables to integers. 
If undefined behaviour occurs, we have an abnormal termination. 
Thus the evaluation of commands goes from a store to a (potentially new) store or an abnormal termination, denoted by $\lightning$.

We have left out the semantics for arithmetic and boolean expressions, as these follow the standard semantics.
However, it should be noted that we do not allow \texit{division} and \textit{modulo} by zero.
Thus, if one of these occur, the program will terminate with an abnormal store.
Furthermore, ghost variables can only occur in assertion, and not as a part of the program logic. We will com back t that in \cref{sec:hoare}.

\begin{table}[h!]
\centering
\input{Background/semantic}
\caption{Semantics for the \textit{While} language.}
\label{table:semantic}
\end{table}

% TODO: add argumentation for semantic equivalence assertion $\sim$ if assertion then skip else violate.
The semantics describe how to evaluate statements in \textit{While}. The most interesting semantic rules in our language are the ones for while loops.
Here we have to assert that the loop invariant holds both at the beginning of each loop iteration, and after loop termination.
If the invariant ever evaluates to \textit{false}, the program is not valid.

\begin{figure}[h]
\lstinputlisting{Examplecode/basicmult.ifc}
\caption{Example program \texttt{mult.ifc}}
\label{figure:basicmult}
\end{figure}

\paragraph{Multiplication as an example.}
To show what the language is capable of, a small example program computing the multiplication of two integers $q$ and $r$ is presented in \cref{figure:basicmult}. 
We will use this program as an example throughout the report.
Line 2 shows the syntax of assignments, lines $3$-$6$ shows the syntax of while loops, and the entire program is also a demonstration of sequencing statements.
For now, we leave out the assertions, but we will come back to this in \cref{sec:hoare}.

Now even though this small \textit{While} language is very simple, it is still very interesting as base language for our project.
By creating an assertion language that can prove the correctness for programs written in this simple language, we can investigate the possibility of proving termination and correctness of while loops, which are definitely the tricky construct of this language.
Loops are specifically challenging because we cannot know whether they ever terminate. Furthermore the way a loop affects program variables is less see-through than for example the effects of an assignment.
Therefore it is desirable to be able to prove the correctness, and idealy termination also, of such program contructs, and that is why this small language is well suited for the purpose of this project.
